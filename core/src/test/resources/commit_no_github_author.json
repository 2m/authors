{
  "sha": "5566808a78cefc888a0d699307fecf92cba442d8",
  "commit": {
    "author": {
      "name": "Veiga Ortiz, Héctor",
      "email": "hector.veiga-ortiz@here.com",
      "date": "2016-11-21T23:04:02Z"
    },
    "committer": {
      "name": "Veiga Ortiz, Héctor",
      "email": "hector.veiga-ortiz@here.com",
      "date": "2016-11-21T23:04:02Z"
    },
    "message": "#21172 module as part of cluster-management",
    "tree": {
      "sha": "e249c20e5d640a9d59501ae0eba7f1dc26388ceb",
      "url": "https://api.github.com/repos/akka/akka-cluster-management/git/trees/e249c20e5d640a9d59501ae0eba7f1dc26388ceb"
    },
    "url": "https://api.github.com/repos/akka/akka-cluster-management/git/commits/5566808a78cefc888a0d699307fecf92cba442d8",
    "comment_count": 0
  },
  "url": "https://api.github.com/repos/akka/akka-cluster-management/commits/5566808a78cefc888a0d699307fecf92cba442d8",
  "html_url": "https://github.com/akka/akka-cluster-management/commit/5566808a78cefc888a0d699307fecf92cba442d8",
  "comments_url": "https://api.github.com/repos/akka/akka-cluster-management/commits/5566808a78cefc888a0d699307fecf92cba442d8/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "1736b21db13ca5b84609cc4bcac15d432b5fae51",
      "url": "https://api.github.com/repos/akka/akka-cluster-management/commits/1736b21db13ca5b84609cc4bcac15d432b5fae51",
      "html_url": "https://github.com/akka/akka-cluster-management/commit/1736b21db13ca5b84609cc4bcac15d432b5fae51"
    }
  ],
  "stats": {
    "total": 1250,
    "additions": 1239,
    "deletions": 11
  },
  "files": [
    {
      "sha": "0a54c320c880d17d3243bc1fa0de8bb90bc6f126",
      "filename": "README.md",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/README.md",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/README.md",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/README.md?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -1 +1,3 @@\n-# akka-cluster-management\n\\ No newline at end of file\n+# akka-cluster-management\n+\n+This repository contains interfaces to interact with an Akka Cluster.\n\\ No newline at end of file"
    },
    {
      "sha": "61dbc737d1c8738ae9572d200d792f39d9a4b5cd",
      "filename": "cluster-http/src/main/resources/reference.conf",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/main/resources/reference.conf",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/main/resources/reference.conf",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/main/resources/reference.conf?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -5,6 +5,13 @@\n # This is the reference config file that contains all the default settings.\n # Make your edits/overrides in your application.conf.\n \n-akka.management.cluster.http {\n+akka.cluster.http.management {\n \n-}\n+  # The hostname where the HTTP Server for Http Cluster Management will be started.\n+  # This defines the interface to use.\n+  hostname = \"127.0.0.1\"\n+\n+  # The port where the HTTP Server for Http Cluster Management will be bound.\n+  # The value will need to be from 0 to 65535.\n+  port = 19999\n+}\n\\ No newline at end of file"
    },
    {
      "sha": "fba120d2f2187650bd69e20a8db252bef41d0ff8",
      "filename": "cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagement.scala",
      "status": "added",
      "additions": 357,
      "deletions": 0,
      "changes": 357,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagement.scala",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagement.scala",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagement.scala?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>\n+ */\n+package akka.cluster.http.management\n+\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import akka.Done\n+import akka.actor.AddressFromURIString\n+import akka.cluster.{ Cluster, Member }\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\n+import akka.http.scaladsl.model.StatusCodes\n+import akka.http.scaladsl.server.Directives._\n+import akka.http.scaladsl.server.{ Route, RouteResult }\n+import akka.http.scaladsl.{ ConnectionContext, Http }\n+import akka.stream.ActorMaterializer\n+import spray.json.DefaultJsonProtocol\n+\n+import scala.concurrent.{ Future, Promise }\n+\n+final case class ClusterUnreachableMember(node: String, observedBy: Seq[String])\n+final case class ClusterMember(node: String, nodeUid: String, status: String, roles: Set[String])\n+final case class ClusterMembers(selfNode: String, members: Set[ClusterMember], unreachable: Seq[ClusterUnreachableMember])\n+final case class ClusterHttpManagementMessage(message: String)\n+\n+private[akka] sealed trait ClusterHttpManagementOperation\n+private[akka] case object Down extends ClusterHttpManagementOperation\n+private[akka] case object Leave extends ClusterHttpManagementOperation\n+private[akka] case object Join extends ClusterHttpManagementOperation\n+\n+object ClusterHttpManagementOperation {\n+  def fromString(value: String): Option[ClusterHttpManagementOperation] = {\n+    Vector(Down, Leave, Join).find(_.toString.equalsIgnoreCase(value))\n+  }\n+}\n+\n+trait ClusterHttpManagementJsonProtocol extends SprayJsonSupport with DefaultJsonProtocol {\n+  implicit val clusterUnreachableMemberFormat = jsonFormat2(ClusterUnreachableMember)\n+  implicit val clusterMemberFormat = jsonFormat4(ClusterMember)\n+  implicit val clusterMembersFormat = jsonFormat3(ClusterMembers)\n+  implicit val clusterMemberMessageFormat = jsonFormat1(ClusterHttpManagementMessage)\n+}\n+\n+trait ClusterHttpManagementHelper extends ClusterHttpManagementJsonProtocol {\n+  def memberToClusterMember(m: Member): ClusterMember = {\n+    ClusterMember(s\"${m.uniqueAddress.address}\", s\"${m.uniqueAddress.longUid}\", s\"${m.status}\", m.roles)\n+  }\n+}\n+\n+object ClusterHttpManagementRoutes extends ClusterHttpManagementHelper {\n+\n+  private def routeGetMembers(cluster: Cluster) = {\n+    get {\n+      complete {\n+        val members = cluster.readView.state.members.map(memberToClusterMember)\n+\n+        val unreachable = cluster.readView.reachability.observersGroupedByUnreachable.toSeq.sortBy(_._1).map {\n+          case (subject, observers) ⇒\n+            ClusterUnreachableMember(s\"${subject.address}\", observers.toSeq.sorted.map(m ⇒ s\"${m.address}\"))\n+        }\n+\n+        ClusterMembers(s\"${cluster.readView.selfAddress}\", members, unreachable)\n+      }\n+    }\n+  }\n+\n+  private def routePostMembers(cluster: Cluster) = {\n+    post {\n+      formField('address) { addressString ⇒\n+        complete {\n+          val address = AddressFromURIString(addressString)\n+          cluster.join(address)\n+          ClusterHttpManagementMessage(s\"Joining $address\")\n+        }\n+      }\n+    }\n+  }\n+\n+  private def routeGetMember(cluster: Cluster, member: Member) =\n+    get {\n+      complete {\n+        memberToClusterMember(member)\n+      }\n+    }\n+\n+  private def routeDeleteMember(cluster: Cluster, member: Member) =\n+    delete {\n+      complete {\n+        cluster.leave(member.uniqueAddress.address)\n+        ClusterHttpManagementMessage(s\"Leaving ${member.uniqueAddress.address}\")\n+      }\n+    }\n+\n+  private def routePutMember(cluster: Cluster, member: Member) =\n+    put {\n+      formField('operation) { operation ⇒\n+        ClusterHttpManagementOperation.fromString(operation) match {\n+          case Some(Down) ⇒\n+            cluster.down(member.uniqueAddress.address)\n+            complete(ClusterHttpManagementMessage(s\"Downing ${member.uniqueAddress.address}\"))\n+          case Some(Leave) ⇒\n+            cluster.leave(member.uniqueAddress.address)\n+            complete(ClusterHttpManagementMessage(s\"Leaving ${member.uniqueAddress.address}\"))\n+          case _ ⇒\n+            complete(StatusCodes.BadRequest → ClusterHttpManagementMessage(\"Operation not supported\"))\n+        }\n+      }\n+    }\n+\n+  private def routesMember(cluster: Cluster) =\n+    path(Remaining) { memberAddress ⇒\n+      cluster.readView.members.find(m ⇒ s\"${m.uniqueAddress.address}\" == memberAddress) match {\n+        case Some(member) ⇒\n+          routeGetMember(cluster, member) ~ routeDeleteMember(cluster, member) ~ routePutMember(cluster, member)\n+        case None ⇒\n+          complete(StatusCodes.NotFound → ClusterHttpManagementMessage(s\"Member [$memberAddress] not found\"))\n+      }\n+    }\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagementRoutes]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version does not provide Basic Authentication. It uses\n+   * the default path \"members\".\n+   */\n+  def apply(cluster: Cluster): Route = apply(cluster, \"members\")\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagementRoutes]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version does not provide Basic Authentication. It uses\n+   * the specified path `pathPrefixName`.\n+   */\n+  def apply(cluster: Cluster, pathPrefixName: String): Route =\n+    pathPrefix(pathPrefixName) {\n+      pathEndOrSingleSlash {\n+        routeGetMembers(cluster) ~ routePostMembers(cluster)\n+      } ~\n+        routesMember(cluster)\n+    }\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagementRoutes]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication through the specified\n+   * AsyncAuthenticator. It uses the default path \"members\".\n+   */\n+  def apply(cluster: Cluster, asyncAuthenticator: AsyncAuthenticator[String]): Route = {\n+    authenticateBasicAsync[String](realm = \"secured\", asyncAuthenticator) { _ ⇒\n+      apply(cluster)\n+    }\n+  }\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagementRoutes]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication through the specified\n+   * AsyncAuthenticator. It uses the specified path `pathPrefixName`.\n+   */\n+  def apply(cluster: Cluster, pathPrefixName: String, asyncAuthenticator: AsyncAuthenticator[String]): Route = {\n+    authenticateBasicAsync[String](realm = \"secured\", asyncAuthenticator) { _ ⇒\n+      apply(cluster, pathPrefixName)\n+    }\n+  }\n+}\n+\n+object ClusterHttpManagement {\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version does not provide security (Basic Authentication or SSL)\n+   * and uses the default path \"members\".\n+   */\n+  def apply(cluster: Cluster): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version does not provide security (Basic Authentication or SSL).\n+   * It uses the specified path `pathPrefix`.\n+   */\n+  def apply(cluster: Cluster, pathPrefix: String): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster, Some(pathPrefix), None, None)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It does not provide SSL security. It uses the default path \"members\".\n+   */\n+  def apply(cluster: Cluster, asyncAuthenticator: AsyncAuthenticator[String]): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster, None, Some(asyncAuthenticator), None)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides SSL with the specified ConnectionContext.\n+   * It does not provide Basic Authentication. It uses the default path \"members\".\n+   */\n+  def apply(cluster: Cluster, https: ConnectionContext): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster, None, None, Some(https))\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It does not provide SSL security. It uses the specified path `pathPrefix`.\n+   */\n+  def apply(cluster: Cluster, pathPrefix: String, asyncAuthenticator: AsyncAuthenticator[String]): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster, Some(pathPrefix), Some(asyncAuthenticator), None)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides SSL with the specified ConnectionContext.\n+   * It does not provide Basic Authentication. It uses the specified path `pathPrefix`.\n+   */\n+  def apply(cluster: Cluster, pathPrefix: String, https: ConnectionContext) =\n+    new ClusterHttpManagement(cluster, Some(pathPrefix), None, Some(https))\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It provide SSL with the specified ConnectionContext. It uses the default path \"members\".\n+   */\n+  def apply(cluster: Cluster, asyncAuthenticator: AsyncAuthenticator[String], https: ConnectionContext): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster, None, Some(asyncAuthenticator), Some(https))\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It provide SSL with the specified ConnectionContext. It uses the specified path `pathPrefix`.\n+   */\n+  def apply(cluster: Cluster, pathPrefix: String, asyncAuthenticator: AsyncAuthenticator[String], https: ConnectionContext): ClusterHttpManagement =\n+    new ClusterHttpManagement(cluster, Some(pathPrefix), Some(asyncAuthenticator), Some(https))\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version does not provide security (Basic Authentication or SSL)\n+   * and uses the default path \"members\".\n+   */\n+  def create(cluster: Cluster): ClusterHttpManagement =\n+    apply(cluster)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version does not provide security (Basic Authentication or SSL).\n+   * It uses the specified path `pathPrefix`.\n+   */\n+  def create(cluster: Cluster, pathPrefix: String): ClusterHttpManagement =\n+    apply(cluster, pathPrefix)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It does not provide SSL security. It uses the default path \"members\".\n+   */\n+  def create(cluster: Cluster, asyncAuthenticator: AsyncAuthenticator[String]): ClusterHttpManagement =\n+    apply(cluster, asyncAuthenticator)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides SSL with the specified ConnectionContext.\n+   * It does not provide Basic Authentication. It uses the default path \"members\".\n+   */\n+  def create(cluster: Cluster, https: ConnectionContext): ClusterHttpManagement =\n+    apply(cluster, https)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It does not provide SSL security. It uses the specified path `pathPrefix`.\n+   */\n+  def create(cluster: Cluster, pathPrefix: String, asyncAuthenticator: AsyncAuthenticator[String]): ClusterHttpManagement =\n+    apply(cluster, pathPrefix, asyncAuthenticator)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides SSL with the specified ConnectionContext.\n+   * It does not provide Basic Authentication. It uses the specified path `pathPrefix`.\n+   */\n+  def create(cluster: Cluster, pathPrefix: String, https: ConnectionContext) =\n+    apply(cluster, pathPrefix, https)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It provide SSL with the specified ConnectionContext. It uses the default path \"members\".\n+   */\n+  def create(cluster: Cluster, asyncAuthenticator: AsyncAuthenticator[String], https: ConnectionContext): ClusterHttpManagement =\n+    apply(cluster, asyncAuthenticator, https)\n+\n+  /**\n+   * Creates an instance of [[akka.cluster.http.management.ClusterHttpManagement]] to manage the specified\n+   * [[akka.cluster.Cluster]] instance. This version provides Basic Authentication with the specified\n+   * AsyncAuthenticator. It provide SSL with the specified ConnectionContext. It uses the specified path `pathPrefix`.\n+   */\n+  def create(cluster: Cluster, pathPrefix: String, asyncAuthenticator: AsyncAuthenticator[String], https: ConnectionContext): ClusterHttpManagement =\n+    apply(cluster, pathPrefix, asyncAuthenticator, https)\n+}\n+\n+/**\n+ * Class to instantiate an [[akka.cluster.http.management.ClusterHttpManagement]] to\n+ * provide an HTTP management interface for [[akka.cluster.Cluster]].\n+ */\n+class ClusterHttpManagement(\n+  cluster:            Cluster,\n+  pathPrefix:         Option[String]                     = None,\n+  asyncAuthenticator: Option[AsyncAuthenticator[String]] = None,\n+  https:              Option[ConnectionContext]          = None\n+) {\n+\n+  private val settings = new ClusterHttpManagementSettings(cluster.system.settings.config)\n+  private implicit val system = cluster.system\n+  private implicit val materializer = ActorMaterializer()\n+  import system.dispatcher\n+\n+  private val bindingFuture = new AtomicReference[Future[Http.ServerBinding]]()\n+\n+  def start(): Future[Done] = {\n+    val serverBindingPromise = Promise[Http.ServerBinding]()\n+    if (bindingFuture.compareAndSet(null, serverBindingPromise.future)) {\n+      val clusterHttpManagementRoutes = (pathPrefix, asyncAuthenticator) match {\n+        case (Some(pp), Some(aa)) ⇒ ClusterHttpManagementRoutes(cluster, pp, aa)\n+        case (Some(pp), None)     ⇒ ClusterHttpManagementRoutes(cluster, pp)\n+        case (None, Some(aa))     ⇒ ClusterHttpManagementRoutes(cluster, aa)\n+        case (None, None)         ⇒ ClusterHttpManagementRoutes(cluster)\n+      }\n+\n+      val routes = RouteResult.route2HandlerFlow(clusterHttpManagementRoutes)\n+\n+      val serverFutureBinding = https match {\n+        case Some(context) ⇒\n+          Http().bindAndHandle(\n+            routes,\n+            settings.ClusterHttpManagementHostname,\n+            settings.ClusterHttpManagementPort,\n+            connectionContext = context\n+          )\n+        case None ⇒\n+          Http().bindAndHandle(\n+            routes,\n+            settings.ClusterHttpManagementHostname,\n+            settings.ClusterHttpManagementPort\n+          )\n+      }\n+\n+      serverBindingPromise.completeWith(serverFutureBinding)\n+      serverBindingPromise.future.map(_ => Done)\n+    } else {\n+      Future(Done)\n+    }\n+  }\n+\n+  def stop(): Future[Done] = {\n+    if (bindingFuture.get() == null) {\n+      Future(Done)\n+    } else {\n+      val stopFuture = bindingFuture.get().flatMap(_.unbind()).map(_ => Done)\n+      bindingFuture.set(null)\n+      stopFuture\n+    }\n+  }\n+}\n+"
    },
    {
      "sha": "b913d6fd2a57d82f98767ddb55f49abceb751a99",
      "filename": "cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagementSettings.scala",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagementSettings.scala",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagementSettings.scala",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/main/scala/akka/cluster/http/management/ClusterHttpManagementSettings.scala?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,12 @@\n+/*\n+ * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>\n+ */\n+package akka.cluster.http.management\n+\n+import com.typesafe.config.Config\n+\n+final class ClusterHttpManagementSettings(val config: Config) {\n+  private val cc = config.getConfig(\"akka.cluster.http.management\")\n+  val ClusterHttpManagementPort = cc.getInt(\"port\")\n+  val ClusterHttpManagementHostname = cc.getString(\"hostname\")\n+}"
    },
    {
      "sha": "094cc14acfa297355cbcefa1e885103bfa4be78d",
      "filename": "cluster-http/src/main/scala/akka/management/cluster/http/ClusterHttpManagement.scala",
      "status": "removed",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/1736b21db13ca5b84609cc4bcac15d432b5fae51/cluster-http/src/main/scala/akka/management/cluster/http/ClusterHttpManagement.scala",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/1736b21db13ca5b84609cc4bcac15d432b5fae51/cluster-http/src/main/scala/akka/management/cluster/http/ClusterHttpManagement.scala",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/main/scala/akka/management/cluster/http/ClusterHttpManagement.scala?ref=1736b21db13ca5b84609cc4bcac15d432b5fae51",
      "patch": "@@ -1,6 +0,0 @@\n-/*\n- * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>\n- */\n-package akka.management.cluster.http\n-\n-object ClusterHttpManagement {}"
    },
    {
      "sha": "2ebd8ea716403e694ef387ffd7dbb0614a107493",
      "filename": "cluster-http/src/test/java/akka/cluster/http/management/ClusterHttpManagementJavaCompileTest.java",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/java/akka/cluster/http/management/ClusterHttpManagementJavaCompileTest.java",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/java/akka/cluster/http/management/ClusterHttpManagementJavaCompileTest.java",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/test/java/akka/cluster/http/management/ClusterHttpManagementJavaCompileTest.java?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>\n+ */\n+package akka.cluster.http.management;\n+\n+import akka.actor.ActorSystem;\n+import akka.cluster.Cluster;\n+import org.junit.Test;\n+\n+public class ClusterHttpManagementJavaCompileTest {\n+\n+    public void test() {\n+        ActorSystem actorSystem = ActorSystem.create(\"test\");\n+        Cluster cluster = Cluster.get(actorSystem);\n+        ClusterHttpManagement x = ClusterHttpManagement.create(cluster);\n+        x.start();\n+    }\n+\n+    @Test\n+    public void compileOnly() {}\n+}"
    },
    {
      "sha": "9732f42e9a6938a6fa82a4dffe83f2da9d8c43cc",
      "filename": "cluster-http/src/test/resources/httpsDemoKeys/keys/keystore.p12",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/resources/httpsDemoKeys/keys/keystore.p12",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/resources/httpsDemoKeys/keys/keystore.p12",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/test/resources/httpsDemoKeys/keys/keystore.p12?ref=5566808a78cefc888a0d699307fecf92cba442d8"
    },
    {
      "sha": "7937c475d54567ea5c014b365781b0608ed31f46",
      "filename": "cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementRoutesSpec.scala",
      "status": "added",
      "additions": 254,
      "deletions": 0,
      "changes": 254,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementRoutesSpec.scala",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementRoutesSpec.scala",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementRoutesSpec.scala?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>\n+ */\n+package akka.cluster.http.management\n+\n+import akka.actor.Address\n+import akka.cluster.ClusterEvent.CurrentClusterState\n+import akka.cluster._\n+import akka.http.scaladsl.model.{ FormData, StatusCodes }\n+import akka.http.scaladsl.testkit.ScalatestRouteTest\n+import org.mockito.Mockito._\n+import org.mockito.Matchers._\n+import org.scalatest.{ Matchers, WordSpecLike }\n+\n+import scala.collection.immutable._\n+\n+class ClusterHttpManagementRoutesSpec extends WordSpecLike with Matchers with ScalatestRouteTest with ClusterHttpManagementJsonProtocol {\n+\n+  \"Http Cluster Management Routes\" should {\n+    \"return list of members\" when {\n+      \"calling GET /members\" in {\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+        val address2 = Address(\"akka\", \"Main\", \"hostname2.com\", 3311)\n+        val address3 = Address(\"akka\", \"Main\", \"hostname3.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+        val uniqueAddress2 = UniqueAddress(address2, 2L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+        val clusterMember2 = Member(uniqueAddress2, Set())\n+        val currentClusterState = CurrentClusterState(SortedSet(clusterMember1, clusterMember2))\n+\n+        val unreachable = Map(\n+          UniqueAddress(address3, 2L) → Set(uniqueAddress1, uniqueAddress2)\n+        )\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        val mockedReachability = mock(classOf[Reachability])\n+\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.state).thenReturn(currentClusterState)\n+        when(mockedClusterReadView.selfAddress).thenReturn(address1)\n+        when(mockedClusterReadView.reachability).thenReturn(mockedReachability)\n+        when(mockedReachability.observersGroupedByUnreachable).thenReturn(unreachable)\n+\n+        Get(\"/members\") ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          val clusterUnreachableMember = ClusterUnreachableMember(\"akka://Main@hostname3.com:3311\", Seq(\"akka://Main@hostname.com:3311\", \"akka://Main@hostname2.com:3311\"))\n+          val clusterMembers = Set(ClusterMember(\"akka://Main@hostname.com:3311\", \"1\", \"Joining\", Set()), ClusterMember(\"akka://Main@hostname2.com:3311\", \"2\", \"Joining\", Set()))\n+          responseAs[ClusterMembers] shouldEqual ClusterMembers(s\"$address1\", clusterMembers, Seq(clusterUnreachableMember))\n+          status == StatusCodes.OK\n+        }\n+      }\n+    }\n+\n+    \"join a member\" when {\n+      \"calling POST /members with form field 'memberAddress'\" in {\n+        val address = \"akka.tcp://Main@hostname.com:3311\"\n+        val urlEncodedForm = FormData(Map(\"address\" → address))\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        doNothing().when(mockedCluster).join(any[Address])\n+\n+        Post(\"/members/\", urlEncodedForm) ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(s\"Joining $address\")\n+          status == StatusCodes.OK\n+        }\n+      }\n+    }\n+\n+    \"return information of a member\" when {\n+      \"calling GET /members/akka://Main@hostname.com:3311\" in {\n+        val address = \"akka://Main@hostname.com:3311\"\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+\n+        val members = SortedSet(clusterMember1)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).leave(any[Address])\n+\n+        Get(s\"/members/$address\") ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterMember] shouldEqual ClusterMember(\"akka://Main@hostname.com:3311\", \"1\", \"Joining\", Set())\n+          status == StatusCodes.OK\n+        }\n+      }\n+    }\n+\n+    \"execute leave on a member\" when {\n+      \"calling DELETE /members/akka://Main@hostname.com:3311\" in {\n+        val address = \"akka://Main@hostname.com:3311\"\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+        val address2 = Address(\"akka\", \"Main\", \"hostname2.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+        val uniqueAddress2 = UniqueAddress(address2, 2L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+        val clusterMember2 = Member(uniqueAddress2, Set())\n+\n+        val members = SortedSet(clusterMember1, clusterMember2)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).leave(any[Address])\n+\n+        Delete(s\"/members/$address\") ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(s\"Leaving $address\")\n+          status == StatusCodes.OK\n+        }\n+      }\n+\n+      \"calling PUT /members/akka://Main@hostname.com:3311 with form field operation LEAVE\" in {\n+        val address = \"akka://Main@hostname.com:3311\"\n+        val urlEncodedForm = FormData(Map(\"operation\" → \"leave\"))\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+        val address2 = Address(\"akka\", \"Main\", \"hostname2.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+        val uniqueAddress2 = UniqueAddress(address2, 2L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+        val clusterMember2 = Member(uniqueAddress2, Set())\n+\n+        val members = SortedSet(clusterMember1, clusterMember2)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).leave(any[Address])\n+\n+        Put(s\"/members/$address\", urlEncodedForm) ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(s\"Leaving $address\")\n+          status == StatusCodes.OK\n+        }\n+      }\n+\n+      \"does not exist and return Not Found\" in {\n+        val address = \"akka://Main2@hostname.com:3311\"\n+        val urlEncodedForm = FormData(Map(\"operation\" → \"leave\"))\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+\n+        val members = SortedSet(clusterMember1)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).down(any[Address])\n+\n+        Put(s\"/members/$address\", urlEncodedForm) ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(s\"Member [$address] not found\")\n+          status == StatusCodes.NotFound\n+        }\n+      }\n+    }\n+\n+    \"execute down on a member\" when {\n+      \"calling PUT /members/akka://Main@hostname.com:3311 with form field operation DOWN\" in {\n+        val address = \"akka://Main@hostname.com:3311\"\n+        val urlEncodedForm = FormData(Map(\"operation\" → \"down\"))\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+        val address2 = Address(\"akka\", \"Main\", \"hostname2.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+        val uniqueAddress2 = UniqueAddress(address2, 2L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+        val clusterMember2 = Member(uniqueAddress2, Set())\n+\n+        val members = SortedSet(clusterMember1, clusterMember2)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).down(any[Address])\n+\n+        Put(s\"/members/$address\", urlEncodedForm) ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(s\"Downing $address\")\n+          status == StatusCodes.OK\n+        }\n+      }\n+\n+      \"does not exist and return Not Found\" in {\n+        val address = \"akka://Main2@hostname.com:3311\"\n+        val urlEncodedForm = FormData(Map(\"operation\" → \"down\"))\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+\n+        val members = SortedSet(clusterMember1)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).down(any[Address])\n+\n+        Put(s\"/members/$address\", urlEncodedForm) ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(s\"Member [$address] not found\")\n+          status == StatusCodes.NotFound\n+        }\n+      }\n+    }\n+\n+    \"return not found operation\" when {\n+      \"calling PUT /members/akka://Main@hostname.com:3311 with form field operation UNKNOWN\" in {\n+        val address = \"akka://Main@hostname.com:3311\"\n+        val urlEncodedForm = FormData(Map(\"operation\" → \"unknown\"))\n+\n+        val address1 = Address(\"akka\", \"Main\", \"hostname.com\", 3311)\n+\n+        val uniqueAddress1 = UniqueAddress(address1, 1L)\n+\n+        val clusterMember1 = Member(uniqueAddress1, Set())\n+\n+        val members = SortedSet(clusterMember1)\n+\n+        val mockedCluster = mock(classOf[Cluster])\n+        val mockedClusterReadView = mock(classOf[ClusterReadView])\n+        when(mockedCluster.readView).thenReturn(mockedClusterReadView)\n+        when(mockedClusterReadView.members).thenReturn(members)\n+        doNothing().when(mockedCluster).down(any[Address])\n+\n+        Put(s\"/members/$address\", urlEncodedForm) ~> ClusterHttpManagementRoutes(mockedCluster) ~> check {\n+          responseAs[ClusterHttpManagementMessage] shouldEqual ClusterHttpManagementMessage(\"Operation not supported\")\n+          status == StatusCodes.NotFound\n+        }\n+      }\n+    }\n+  }\n+}"
    },
    {
      "sha": "b5f0cfb5ba7aef8fa7f6914d1688b759eae6a554",
      "filename": "cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementSpec.scala",
      "status": "added",
      "additions": 194,
      "deletions": 0,
      "changes": 194,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementSpec.scala",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementSpec.scala",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/cluster-http/src/test/scala/akka/cluster/http/management/ClusterHttpManagementSpec.scala?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>\n+ */\n+package akka.cluster.http.management\n+\n+import java.io.InputStream\n+import java.security.{ KeyStore, SecureRandom }\n+import javax.net.ssl.{ KeyManagerFactory, SSLContext, TrustManagerFactory }\n+\n+import akka.actor.{ ActorSystem, ExtendedActorSystem }\n+import akka.cluster.InternalClusterAction.LeaderActionsTick\n+import akka.cluster._\n+import akka.http.scaladsl.{ ConnectionContext, Http, HttpsConnectionContext }\n+import akka.http.scaladsl.model.headers.{ Authorization, BasicHttpCredentials }\n+import akka.http.scaladsl.model.{ ContentTypes, HttpRequest, StatusCodes }\n+import akka.http.scaladsl.server.directives.Credentials\n+import akka.http.scaladsl.unmarshalling.Unmarshal\n+import akka.stream.ActorMaterializer\n+import com.typesafe.config.ConfigFactory\n+import org.scalatest.{ Matchers, WordSpecLike }\n+\n+import scala.concurrent.{ Await, Future }\n+import scala.concurrent.duration._\n+\n+class ClusterHttpManagementSpec extends WordSpecLike with Matchers\n+  with ClusterHttpManagementJsonProtocol with ClusterHttpManagementHelper {\n+\n+  val config = ConfigFactory.parseString(\n+    \"\"\"\n+      |akka.cluster {\n+      |  auto-down-unreachable-after = 0s\n+      |  periodic-tasks-initial-delay = 120 seconds // turn off scheduled tasks\n+      |  publish-stats-interval = 0 s # always, when it happens\n+      |  failure-detector.implementation-class = akka.cluster.FailureDetectorPuppet\n+      |}\n+      |akka.actor.provider = \"cluster\"\n+      |akka.remote.log-remote-lifecycle-events = off\n+      |akka.remote.netty.tcp.port = 0\n+      |#akka.loglevel = DEBUG\n+    \"\"\".stripMargin\n+  )\n+\n+  \"Http Cluster Management\" should {\n+    \"start and stop\" when {\n+      \"not setting any security\" in {\n+        val configClusterHttpManager = ConfigFactory.parseString(\n+          \"\"\"\n+            |akka.cluster.http.management.hostname = \"127.0.0.1\"\n+            |akka.cluster.http.management.port = 19999\n+          \"\"\".stripMargin\n+        )\n+\n+        implicit val system = ActorSystem(\"test\", config.withFallback(configClusterHttpManager))\n+        import system.dispatcher\n+        val cluster = Cluster(system)\n+\n+        val selfAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress\n+        cluster.join(selfAddress)\n+        cluster.clusterCore ! LeaderActionsTick\n+\n+        val clusterHttpManagement = ClusterHttpManagement(cluster)\n+        clusterHttpManagement.start()\n+\n+        implicit val materializer = ActorMaterializer()\n+\n+        val responseGetMembersFuture = Http().singleRequest(HttpRequest(uri = \"http://127.0.0.1:19999/members\"))\n+        val responseGetMembers = Await.result(responseGetMembersFuture, 5 seconds)\n+\n+        Unmarshal(responseGetMembers.entity).to[ClusterMembers].onSuccess {\n+          case clusterMembers: ClusterMembers ⇒\n+            memberToClusterMember(cluster.readView.members.head) shouldEqual clusterMembers.members.head\n+        }\n+\n+        responseGetMembers.entity.getContentType shouldEqual ContentTypes.`application/json`\n+        responseGetMembers.status shouldEqual StatusCodes.OK\n+\n+        val bindingFuture = clusterHttpManagement.stop()\n+        Await.ready(bindingFuture, 5 seconds)\n+        system.terminate()\n+      }\n+\n+      \"setting basic authentication\" in {\n+        val configClusterHttpManager = ConfigFactory.parseString(\n+          \"\"\"\n+            |akka.cluster.http.management.hostname = \"127.0.0.1\"\n+            |akka.cluster.http.management.port = 20000\n+          \"\"\".stripMargin\n+        )\n+\n+        implicit val system = ActorSystem(\"test\", config.withFallback(configClusterHttpManager))\n+        import system.dispatcher\n+        val cluster = Cluster(system)\n+\n+        val selfAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress\n+        cluster.join(selfAddress)\n+        cluster.clusterCore ! LeaderActionsTick\n+\n+        def myUserPassAuthenticator(credentials: Credentials): Future[Option[String]] =\n+          credentials match {\n+            case p @ Credentials.Provided(id) ⇒\n+              Future {\n+                // potentially\n+                if (p.verify(\"p4ssw0rd\")) Some(id)\n+                else None\n+              }\n+            case _ ⇒ Future.successful(None)\n+          }\n+\n+        val clusterHttpManagement = ClusterHttpManagement(cluster, myUserPassAuthenticator(_))\n+        clusterHttpManagement.start()\n+\n+        implicit val materializer = ActorMaterializer()\n+\n+        val httpRequest = HttpRequest(uri = \"http://127.0.0.1:20000/members\")\n+          .addHeader(Authorization(BasicHttpCredentials(\"user\", \"p4ssw0rd\")))\n+        val responseGetMembersFuture = Http().singleRequest(httpRequest)\n+        val responseGetMembers = Await.result(responseGetMembersFuture, 5 seconds)\n+\n+        Unmarshal(responseGetMembers.entity).to[ClusterMembers].onSuccess {\n+          case clusterMembers: ClusterMembers ⇒\n+            memberToClusterMember(cluster.readView.members.head) shouldEqual clusterMembers.members.head\n+        }\n+        responseGetMembers.entity.getContentType shouldEqual ContentTypes.`application/json`\n+        responseGetMembers.status shouldEqual StatusCodes.OK\n+\n+        val bindingFuture = clusterHttpManagement.stop()\n+        Await.ready(bindingFuture, 5 seconds)\n+        system.terminate()\n+      }\n+\n+      \"setting ssl\" in {\n+        val configClusterHttpManager = ConfigFactory.parseString(\n+          \"\"\"\n+            |akka.cluster.http.management.hostname = \"127.0.0.1\"\n+            |akka.cluster.http.management.port = 20001\n+            |\n+            |akka.ssl-config {\n+            |  loose {\n+            |    disableSNI = true\n+            |    disableHostnameVerification = true\n+            |  }\n+            |}\n+          \"\"\".stripMargin\n+        )\n+\n+        implicit val system = ActorSystem(\"test\", config.withFallback(configClusterHttpManager))\n+        import system.dispatcher\n+        val cluster = Cluster(system)\n+\n+        val selfAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress\n+        cluster.join(selfAddress)\n+        cluster.clusterCore ! LeaderActionsTick\n+\n+        val password: Array[Char] = \"password\".toCharArray // do not store passwords in code, read them from somewhere safe!\n+\n+        val ks: KeyStore = KeyStore.getInstance(\"PKCS12\")\n+        val keystore: InputStream = getClass.getClassLoader.getResourceAsStream(\"httpsDemoKeys/keys/keystore.p12\")\n+\n+        require(keystore != null, \"Keystore required!\")\n+        ks.load(keystore, password)\n+\n+        val keyManagerFactory: KeyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\")\n+        keyManagerFactory.init(ks, password)\n+\n+        val tmf: TrustManagerFactory = TrustManagerFactory.getInstance(\"SunX509\")\n+        tmf.init(ks)\n+\n+        val sslContext: SSLContext = SSLContext.getInstance(\"TLS\")\n+        sslContext.init(keyManagerFactory.getKeyManagers, tmf.getTrustManagers, new SecureRandom)\n+        val https: HttpsConnectionContext = ConnectionContext.https(sslContext)\n+\n+        val clusterHttpManagement = ClusterHttpManagement(cluster, https)\n+        clusterHttpManagement.start()\n+\n+        implicit val materializer = ActorMaterializer()\n+\n+        val httpRequest = HttpRequest(uri = \"https://127.0.0.1:20001/members\")\n+        val responseGetMembersFuture = Http().singleRequest(httpRequest, connectionContext = https)\n+        val responseGetMembers = Await.result(responseGetMembersFuture, 5 seconds)\n+\n+        Unmarshal(responseGetMembers.entity).to[ClusterMembers].onSuccess {\n+          case clusterMembers: ClusterMembers ⇒\n+            memberToClusterMember(cluster.readView.members.head) shouldEqual clusterMembers.members.head\n+        }\n+        responseGetMembers.entity.getContentType shouldEqual ContentTypes.`application/json`\n+        responseGetMembers.status shouldEqual StatusCodes.OK\n+\n+        val bindingFuture = clusterHttpManagement.stop()\n+        Await.ready(bindingFuture, 5 seconds)\n+        system.terminate()\n+      }\n+    }\n+  }\n+}"
    },
    {
      "sha": "319e540afa324ad8ac7b306b3c1f5fffe4452d2a",
      "filename": "docs/src/main/paradox/java/cluster-http-management.md",
      "status": "added",
      "additions": 179,
      "deletions": 0,
      "changes": 179,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/docs/src/main/paradox/java/cluster-http-management.md",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/docs/src/main/paradox/java/cluster-http-management.md",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/docs/src/main/paradox/java/cluster-http-management.md?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,179 @@\n+<a id=\"http-cluster-management\"></a>\n+# Cluster Http Management\n+\n+Akka Cluster HTTP Management is module that allows you interaction with an `akka-cluster` through an HTTP interface.\n+This module exposes different operations to manage nodes in a cluster. \n+\n+The operations exposed are comparable to the Command Line Management tool or the JMX interface `akka-cluster` provides.\n+\n+## Preparing your project for Cluster HTTP Management\n+\n+The Akka Cluster HTTP Management is a separate jar file. Make sure that you have the following dependency in your project::\n+\n+  \"com.typesafe.akka\" %% \"akka-cluster-http-management\" % \"@version@\" @crossString@\n+\n+\n+## API Definition\n+\n+The following table describes the usage of the API:\n+\n+| Path | HTTP method | Required form fields | Responses | Description |\n+| ---- | ----------- | -------------------- | --------- | ----------- |\n+| `/members/` | GET | None | See below | Returns the status of the Cluster in JSON format.\n+| `/members/` | POST | address: {address} | See below | Executes join operation in cluster for the provided `{address}`.\n+| `/members/{address}` | GET  | None | See below | Returns the status of `{address}` in the Cluster in JSON format.\n+| `/members/{address}` | DELETE | None | See below | Executes leave operation in cluster for provided `{address}`.\n+| `/members/{address}` | PUT | operation: Down | See below | Executes down operation in cluster for provided `{address}`.\n+| `/members/{address}` | PUT | operation: Leave | See below | Executes leave operation in cluster for provided `{address}`.\n+\n+The expected format of `address` follows the Cluster URI convention. Example: `akka://Main@myhostname.com:3311`\n+\n+### Get /members responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Status of cluster in JSON format |\n+| 500 | Something went wrong. Cluster might be shutdown.|\n+ \n+ Example response:\n+ \n+     {\n+       \"selfNode\": \"akka.tcp://test@10.10.10.10:1111\",\n+       \"members\": [\n+         {\n+           \"node\": \"akka.tcp://test@10.10.10.10:1111\",\n+           \"nodeUid\": \"1116964444\",\n+           \"status\": \"Up\",\n+           \"roles\": []\n+         }\n+       ],\n+       \"unreachable\": []\n+     }\n+\n+### Post /members responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Executing join operation. |\n+| 500 | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    Joining ${address}\n+\n+### Get /members/{address} responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Status of cluster in JSON format |\n+| 404 | No member was found in the cluster for the given `{address}`. |\n+| 500 | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    {\n+      \"node\": \"akka.tcp://test@10.10.10.10:1111\",\n+      \"nodeUid\": \"-169203556\",\n+      \"status\": \"Up\",\n+      \"roles\": []\n+    }\n+\n+### Delete /members/{address} responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Executing leave operation. |\n+| 404 | No member was found in the cluster for the given `{address}`. |\n+| 500 | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    Leaving ${address}\n+\n+### Put /members/{address} responses\n+\n+| Response code | Operation | Description |\n+| ------------- | --------- | ----------- |\n+| 200 | Down  | Executing down operation. |\n+| 200 | Leave | Executing leave operation. |\n+| 400 | - | Operation supplied in `operation` form field is not supported. |\n+| 404 | - | No member was found in the cluster for the given `{address}` |\n+| 500 | - | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    Downing ${address}\n+\n+## Configuration\n+\n+You can configure hostname and port to use for the HTTP Cluster management by overriding the following:\n+\n+    akka.cluster.http.management.hostname = \"127.0.0.1\"\n+    akka.cluster.http.management.port = 19999\n+\n+However, those are the values by default. In case you are running multiple cluster instances within the same JVM these \n+configuration parameters should allow you to expose different cluster management APIs by modifying the port:\n+\n+    //Config Actor system 1\n+    akka.cluster.http.management.hostname = \"127.0.0.1\"\n+    akka.cluster.http.management.port = 19999\n+    \n+    //Config Actor system 2\n+    akka.cluster.http.management.hostname = \"127.0.0.1\"\n+    akka.cluster.http.management.port = 20000\n+    \n+    ... \n+    \n+    ActorSystem actorSystem1 = ActorSystem.create(\"as1\", config1);\n+    Cluster cluster1 = Cluster.get(actorSystem1);\n+    ActorSystem actorSystem2 = ActorSystem.create(\"as2\", config2);\n+    Cluster cluster2 = Cluster.get(actorSystem2);\n+\n+    ClusterHttpManagement.create(cluster1).start();\n+    ClusterHttpManagement.create(cluster2).start();\n+\n+It is also possible to modify the default root path of the API (`members/`). Provide your desired path when starting:\n+\n+    ClusterHttpManagement.create(cluster, \"myClusterName\").start();\n+\n+\n+## Security\n+\n+> **Note:**\n+This module does not provide security by default. It's the developer's choice to add security to this API.\n+\n+The non-secured usage of the module is as follows:\n+\n+    ClusterHttpManagement.create(cluster).start();\n+\n+### Enabling SSL for Cluster HTTP Management\n+\n+To enable SSL you need to provide an `SSLContext`. You can find more information about it in @ref:[Server side https support](http/server-side-https-support.md)\n+\n+    HttpsConnectionContext https = ConnectionContext.https(sslContext);\n+    ClusterHttpManagement.create(cluster, https).start();\n+\n+### Enabling Basic Authentication for Cluster HTTP Management\n+\n+To enable Basic Authentication you need to provide an authenticator. You can find more information in @ref:[Authenticate Basic Async directive](http/routing-dsl/directives/security-directives/authenticateBasicAsync.md)\n+     \n+    ClusterHttpManagement.create(cluster, myUserPassAuthenticator).start();\n+\n+### Enabling SSL and Basic Authentication for Cluster HTTP Management\n+\n+To enable SSL and Basic Authentication you need to provide both an `SSLContext` and an authenticator.\n+     \n+    HttpsConnectionContext https = ConnectionContext.https(sslContext);\n+    ClusterHttpManagement.create(cluster, myUserPassAuthenticator, https).start();\n+\n+## Stopping HTTP Cluster Management\n+\n+In a dynamic environment you might want to start and stop multiple instances of HTTP Cluster Management.\n+You can do so by calling `stop()` on `ClusterHttpManagement`. This method return a `Future<Done>` to inform when the \n+module has been stopped.\n+\n+    ClusterHttpManagement httpClusterManagement = ClusterHttpManagement.create(cluster);\n+    httpClusterManagement.start();\n+    //...\n+    httpClusterManagement.stop();\n+    \n\\ No newline at end of file"
    },
    {
      "sha": "dbe826e6517700a0b4579dd156b861fea4d4640e",
      "filename": "docs/src/main/paradox/scala/cluster-http-management.md",
      "status": "added",
      "additions": 202,
      "deletions": 0,
      "changes": 202,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/docs/src/main/paradox/scala/cluster-http-management.md",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/docs/src/main/paradox/scala/cluster-http-management.md",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/docs/src/main/paradox/scala/cluster-http-management.md?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -0,0 +1,202 @@\n+<a id=\"http-cluster-management\"></a>\n+# Cluster Http Management\n+\n+Akka Cluster HTTP Management is module that allows you interaction with an `akka-cluster` through an HTTP interface.\n+This module exposes different operations to manage nodes in a cluster. \n+\n+The operations exposed are comparable to the Command Line Management tool or the JMX interface `akka-cluster` provides.\n+\n+## Preparing your project for Cluster HTTP Management\n+\n+The Akka Cluster HTTP Management is a separate jar file. Make sure that you have the following dependency in your project::\n+\n+  \"com.typesafe.akka\" %% \"akka-cluster-http-management\" % \"@version@\" @crossString@\n+\n+\n+## API Definition\n+\n+The following table describes the usage of the API:\n+\n+| Path | HTTP method | Required form fields | Responses | Description |\n+| ---- | ----------- | -------------------- | --------- | ----------- |\n+| `/members/` | GET | None | See below | Returns the status of the Cluster in JSON format.\n+| `/members/` | POST | address: {address} | See below | Executes join operation in cluster for the provided `{address}`.\n+| `/members/{address}` | GET  | None | See below | Returns the status of `{address}` in the Cluster in JSON format.\n+| `/members/{address}` | DELETE | None | See below | Executes leave operation in cluster for provided `{address}`.\n+| `/members/{address}` | PUT | operation: Down | See below | Executes down operation in cluster for provided `{address}`.\n+| `/members/{address}` | PUT | operation: Leave | See below | Executes leave operation in cluster for provided `{address}`.\n+\n+The expected format of `address` follows the Cluster URI convention. Example: `akka://Main@myhostname.com:3311`\n+\n+### Get /members responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Status of cluster in JSON format |\n+| 500 | Something went wrong. Cluster might be shutdown.|\n+ \n+ Example response:\n+ \n+     {\n+       \"selfNode\": \"akka.tcp://test@10.10.10.10:1111\",\n+       \"members\": [\n+         {\n+           \"node\": \"akka.tcp://test@10.10.10.10:1111\",\n+           \"nodeUid\": \"1116964444\",\n+           \"status\": \"Up\",\n+           \"roles\": []\n+         }\n+       ],\n+       \"unreachable\": []\n+     }\n+\n+### Post /members responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Executing join operation. |\n+| 500 | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    Joining ${address}\n+\n+### Get /members/{address} responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Status of cluster in JSON format |\n+| 404 | No member was found in the cluster for the given `{address}`. |\n+| 500 | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    {\n+      \"node\": \"akka.tcp://test@10.10.10.10:1111\",\n+      \"nodeUid\": \"-169203556\",\n+      \"status\": \"Up\",\n+      \"roles\": []\n+    }\n+\n+### Delete /members/{address} responses\n+\n+| Response code | Description |\n+| ------------- | ----------- |\n+| 200 | Executing leave operation. |\n+| 404 | No member was found in the cluster for the given `{address}`. |\n+| 500 | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    Leaving ${address}\n+\n+### Put /members/{address} responses\n+\n+| Response code | Operation | Description |\n+| ------------- | --------- | ----------- |\n+| 200 | Down  | Executing down operation. |\n+| 200 | Leave | Executing leave operation. |\n+| 400 | - | Operation supplied in `operation` form field is not supported. |\n+| 404 | - | No member was found in the cluster for the given `{address}` |\n+| 500 | - | Something went wrong. Cluster might be shutdown.| \n+\n+Example response:\n+\n+    Downing ${address}\n+\n+## Configuration\n+\n+You can configure hostname and port to use for the HTTP Cluster management by overriding the following:\n+\n+    akka.cluster.http.management.hostname = \"127.0.0.1\"\n+    akka.cluster.http.management.port = 19999\n+\n+However, those are the values by default. In case you are running multiple cluster instances within the same JVM these \n+configuration parameters should allow you to expose different cluster management APIs by modifying the port:\n+\n+    //Config Actor system 1\n+    akka.cluster.http.management.hostname = \"127.0.0.1\"\n+    akka.cluster.http.management.port = 19999\n+    \n+    //Config Actor system 2\n+    akka.cluster.http.management.hostname = \"127.0.0.1\"\n+    akka.cluster.http.management.port = 20000\n+    \n+    ... \n+    \n+    val actorSystem1 = ActorSystem(\"as1\", config1)\n+    val cluster1 = Cluster(actorSystem1)\n+    val actorSystem2 = ActorSystem(\"as2\", config2)\n+    val cluster2 = Cluster(actorSystem2)\n+\n+    ClusterHttpManagement(cluster1).start()\n+    ClusterHttpManagement(cluster2).start()\n+\n+It is also possible to modify the default root path of the API (`members/`). Provide your desired path when starting:\n+\n+    ClusterHttpManagement(cluster, \"myClusterName\").start()\n+\n+\n+## Security\n+\n+> **Note:**\n+This module does not provide security by default. It's the developer's choice to add security to this API.\n+\n+The non-secured usage of the module is as follows:\n+\n+    ClusterHttpManagement(cluster).start()\n+\n+### Enabling SSL for Cluster HTTP Management\n+\n+To enable SSL you need to provide an `SSLContext`. You can find more information about it in @ref:[Server side https support](http/server-side-https-support.md)\n+\n+    val https: HttpsConnectionContext = ConnectionContext.https(sslContext)\n+    ClusterHttpManagement(cluster, https).start()\n+\n+### Enabling Basic Authentication for Cluster HTTP Management\n+\n+To enable Basic Authentication you need to provide an authenticator. You can find more information in @ref:[Authenticate Basic Async directive](http/routing-dsl/directives/security-directives/authenticateBasicAsync.md)\n+\n+    def myUserPassAuthenticator(credentials: Credentials): Future[Option[String]] =\n+      credentials match {\n+        case p @ Credentials.Provided(id) =>\n+          Future {\n+            // potentially\n+            if (p.verify(\"p4ssw0rd\")) Some(id)\n+            else None\n+          }\n+        case _ => Future.successful(None)\n+      }\n+      \n+    ClusterHttpManagement(cluster, myUserPassAuthenticator(_)).start()  \n+\n+### Enabling SSL and Basic Authentication for Cluster HTTP Management\n+\n+To enable SSL and Basic Authentication you need to provide both an `SSLContext` and an authenticator.\n+\n+    def myUserPassAuthenticator(credentials: Credentials): Future[Option[String]] =\n+      credentials match {\n+        case p @ Credentials.Provided(id) =>\n+          Future {\n+            // potentially\n+            if (p.verify(\"p4ssw0rd\")) Some(id)\n+            else None\n+          }\n+        case _ => Future.successful(None)\n+      }\n+      \n+    val https: HttpsConnectionContext = ConnectionContext.https(sslContext)\n+    ClusterHttpManagement(cluster, myUserPassAuthenticator(_), https).start()  \n+\n+## Stopping Cluster HTTP Management\n+\n+In a dynamic environment you might want to start and stop multiple instances of HTTP Cluster Management.\n+You can do so by calling `stop()` on `ClusterHttpManagement`. This method return a `Future[Done]` to inform when the \n+module has been stopped.\n+\n+    val httpClusterManagement = ClusterHttpManagement(cluster)\n+    httpClusterManagement.start()\n+    //...\n+    val bindingFuture = httpClusterManagement.stop()\n+    bindingFuture.onComplete { _ => println(\"It's stopped\") }\n+    \n\\ No newline at end of file"
    },
    {
      "sha": "68e8bd4d5e4fc95384d5156974fc80603243b217",
      "filename": "project/Dependencies.scala",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/akka/akka-cluster-management/blob/5566808a78cefc888a0d699307fecf92cba442d8/project/Dependencies.scala",
      "raw_url": "https://github.com/akka/akka-cluster-management/raw/5566808a78cefc888a0d699307fecf92cba442d8/project/Dependencies.scala",
      "contents_url": "https://api.github.com/repos/akka/akka-cluster-management/contents/project/Dependencies.scala?ref=5566808a78cefc888a0d699307fecf92cba442d8",
      "patch": "@@ -5,6 +5,7 @@ object Dependencies {\n   val ScalaVersions = Seq(\"2.11.8\", \"2.12.0\")\n   val AkkaVersion = \"2.4.12\"\n   val AkkaHttpVersion = \"10.0.0-RC2\"\n+  val junitVersion = \"4.12\"\n \n   val Common = Seq(\n     libraryDependencies ++= Seq(\n@@ -14,8 +15,13 @@ object Dependencies {\n \n   val ClusterHttp = Seq(\n     libraryDependencies ++= Seq(\n-      \"com.typesafe.akka\" %% \"akka-cluster\" % AkkaVersion,\n-      \"com.typesafe.akka\" %% \"akka-http\"    % AkkaHttpVersion\n+      \"com.typesafe.akka\" %% \"akka-cluster\"                      % AkkaVersion,\n+      \"com.typesafe.akka\" %% \"akka-http\"                         % AkkaHttpVersion,\n+      \"com.typesafe.akka\" %% \"akka-http-spray-json-experimental\" % \"2.4.11\",\n+      \"io.spray\"          %% \"spray-json\"                        % \"1.3.2\",                  // ApacheV2\n+      \"com.typesafe.akka\" %% \"akka-http-testkit\"                 % AkkaHttpVersion % \"test\",\n+      \"junit\"             % \"junit\"                              % junitVersion    % \"test\",\n+      \"org.mockito\"       % \"mockito-all\"                        % \"1.10.19\"       % \"test\"  // Common Public License 1.0\n     )\n   )\n }"
    }
  ]
}
